# 一、排序
### 提示：一般情况下直接使用sort函数即可
### 冒泡排序
  - 算法思想  
    使用一个指针从左向右扫描,若当前位置比前一位置小/大则交换,否则不作操作  
    第 $n$ 轮确定第 $n$ 小的数字  
    值得注意的是,如果一轮当中没有交换操作则可认定排序完成  

### 快速排序
  - 算法思想  
    在序列中选择一个数字作为基准(称基准数)  
    将序列中小于该基准数的数字移动至基准数左侧,大于的放在右侧  
    对左右两个子序列递归进行上述操作  
    对返回的数列进行合并并返回上一级  
    
### 归并排序
  - 算法思想  
    将序列从中间平分直至每一个子序列长度均为 $1$  
    随后重复进行合并操作,取两个子序列中最小的数放入合并结果数组中并删去  
    重复上一步操作直到完成合并  
    返回上一级
  - 经典应用：求逆序对数量  

  ### 基数排序
  - 算法思想  
    一种非比较型的排序算法最早用于解决卡片排序的问题  
    基数排序将待排序的元素拆分为 $k$ 个关键字  
    逐一对各个关键字排序后完成对所有元素的排序
  - $k-$关键字的比较  
    下面用 $a_i$ 表示元素 $a$ 的第 $i$ 关键字  
    假如元素有 $k$ 个关键字,对于两个元素 $a$ 和 $b$,默认的比较方法是：  
    比较两个元素的第 $1$ 关键字 $a_1$ 和 $b_1$,如果 $a_1 < b_1$ 则 $a < b$,如果 $a_1 > b_1$ 则 $a > b$,如果 $a_1 = b_1$ 则进行下一步;  
    比较两个元素的第 $2$ 关键字 $a_2$ 和 $b_2$,如果 $a_2 < b_2$ 则 $a < b$,如果 $a_2 > b_2$ 则 $a > b$,如果 $a_2 = b_2$ 则进行下一步;  
    ……
    比较两个元素的第 $k$ 关键字 $a_k$ 和 $b_k$,如果 $a_k < b_k$ 则 $a < b$,如果 $a_k > b_k$ 则 $a > b$,如果 $a_k = b_k$ 则 $a = b$。  
  - 稳定性  
    如果对内层关键字的排序是稳定的,则基数排序是稳定的。
  - 时间复杂度  
    通常而言,基数排序比基于比较的排序算法(比如快速排序)要快。但由于需要额外的内存空间,因此当内存空间稀缺时,原地置换算法(比如快速排序)或许是个更好的选择。  
    一般来说,如果每个关键字的值域都不大,就可以使用 计数排序 作为内层排序,此时的复杂度为 $O(kn+\sum\limits_{i=1}^k w_i)$,其中 $w_i$ 为第 $i$ 关键字的值域大小。如果关键字值域很大,就可以直接使用基于比较的 $O(nk\log n)$ 排序而无需使用基数排序了。

  - 空间复杂度  
    空间复杂度总为 $O(k+n)$

  ### 总结
  | 排序算法 | 最优时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 |            额外内存             | 稳定性 |           备注            |
  | :------: | :------------: | :------------: | :------------: | :-----------------------------: | :----: | :-----------------------: |
  | 插入排序 |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |             $O(1)$              |   是   |  复杂度与逆序对个数相关   |
  | 选择排序 |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |             $O(1)$              |   否   |    额外空间可使其稳定     |
  | 冒泡排序 |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |             $O(1)$              |   是   |          代码短           |
  |  堆排序  | $O(n\log_2n)$  | $O(n\log_2n)$  | $O(n\log_2n)$  |             $O(1)$              |   否   |                           |
  | 快速排序 | $O(n\log_2n)$  | $O(n\log_2n)$  |    $O(n^2)$    | 平均$O(n\log_2n)$,最坏$O(n^2)$ |   否   | 常使用$O(n\log_2n)$栈空间 |
  | 归并排序 | $O(n\log_2n)$  | $O(n\log_2n)$  | $O(n\log_2n)$  |             $O(n)$              |   是   |                           |

# 二、贪心
- 概念  
  贪心算法(英语：greedy algorithm),是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪,每一步行动总是按某种指标选取最优的操作。而且他目光短浅,总是只看眼前,并不考虑以后可能造成的影响。
- 基本思路  
  1. 建立数学模型  
  2. 把求解的问题分为若干个子问题
  3. 对每一个子问题求解得到局部最优解
  4. 局部最优解合并为全局最优解  
  注：不同于dp,贪心不保存决策过程每一个子问题解的具体值,不能回退
- 证明方法  
  1. 反证法：如果交换方案中任意两个元素/相邻的两个元素后,答案不会变得更好,那么可以推定目前的解已经是最优解了。  
  2. 归纳法：先算得出边界情况(例如 $n = 1$)的最优解 $F_1$,然后再证明：对于每个 $n$,$F_{n+1}$ 都可以由 $F_{n}$ 推导出结果。
- 常用解法  
  1.排序解法  
    用排序法常见的情况是输入一个包含几个(一般一到两个)权值的数组,通过排序然后遍历模拟计算的方法求出最优值。  
    e.g.[「NOIP2012」 提高组 国王游戏](https://www.luogu.com.cn/problem/P1080)   
    - 题面  
      恰逢 H 国国庆,国王邀请 $n$ 位大臣来玩一个有奖游戏。首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。然后,让这 $n$ 位大臣排成一排,国王站在队伍的最前面。排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。  
      国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。注意,国王的位置始终在队伍的最前面。
    - 解题思路  
      设排序后第 $i$ 个大臣左右手上的数分别为 $a_i$, $b_i$。考虑通过邻项交换法推导贪心策略。  
      用 $s$ 表示第 $i$ 个大臣前面所有人的 $a_i$ 的乘积,那么第 $i$ 个大臣得到的奖赏就是$\dfrac{s} {b_i}$,第 $i + 1$ 个大臣得到的奖赏就是$\dfrac{s \cdot a_i} {b_{i+1}}$。  
      如果我们交换第 $i$ 个大臣与第 $i + 1$ 个大臣,那么此时的第 $i$ 个大臣得到的奖赏就是$\dfrac{s} {b_{i+1}}$,第 $i + 1$ 个大臣得到的奖赏就是$\dfrac{s \cdot a_{i+1}} {b_i}$。  
      如果交换前更优当且仅当$\max \left(\dfrac{s} {b_i}, \dfrac{s \cdot a_i} {b_{i+1}}\right)  < \max \left(\dfrac{s} {b_{i+1}}, \dfrac{s \cdot a_{i+1}} {b_i}\right)$  
      提取出相同的 $s$ 并约分得到$\max \left(\dfrac{1} {b_i}, \dfrac{a_i} {b_{i+1}}\right)  < \max \left(\dfrac{1} {b_{i+1}}, \dfrac{a_{i+1}} {b_i}\right)$  
      然后分式化成整式得到$\max (b_{i+1}, a_i\cdot b_i)  < \max (b_i, a_{i+1}\cdot b_{i+1})$   

  2.后悔解法  
    无论当前的选项是否最优都接受,然后进行比较,如果选择之后不是最优了,则反悔,舍弃掉这个选项;否则,正式接受。如此往复。  
    e.g.[「USACO09OPEN」工作调度 Work Scheduling](https://www.luogu.com.cn/problem/P2949)  
    - 题面  
      约翰的工作日从 $0$ 时刻开始,有 $10^9$ 个单位时间。在任一单位时间,他都可以选择编号 $1$ 到 $N$ 的 $N(1 \leq N \leq 10^5)$ 项工作中的任意一项工作来完成。工作 $i$ 的截止时间是 $D_i(1 \leq D_i \leq 10^9)$,完成后获利是 $P_i( 1\leq P_i\leq 10^9 )$。在给定的工作利润和截止时间下,求约翰能够获得的利润最大为多少。 
    - 解题思路  
      1.先假设每一项工作都做,将各项工作按截止时间排序后入队;  
      2.在判断第 $i$ 项工作做与不做时,若其截至时间符合条件,则将其与队中报酬最小的元素比较,若第 $i$ 项工作报酬较高(后悔),则 $ans += a[i].p - q.top()$。  
      用优先队列(小根堆)来维护队首元素最小。  
      3.当 $a[i].d<=q.size()$ 时可以理解为从 $0$ 开始到 $a[i].d$ 这个时间段只能做 $a[i].d$ 个任务,而若 $q.size()>=a[i].d$ 说明完成 $q.size()$ 个任务时间大于等于 $a[i].d$ 的时间,所以当第 $i$ 个任务获利比较大的时候应该把最小的任务从优先级队列中换出。
- 经典应用：哈夫曼树与哈夫曼编码

# 三、前缀和 & 差分  
### 前缀和
   - 库函数  
    C++ 标准库中实现了前缀和函数 std::partial_sum,定义于头文件 \<numeric> 中。
   - 多维前缀和  
    1.基于容斥原理计算  
    2.dp计算(俗称高维前缀和)
      设高维空间 $U$ 共有 $D$ 维,需要对 $f[\cdot]$ 求高维前缀和 $\text{sum}[\cdot]$。令 $\text{sum}[i][\text{state}]$ 表示同 $\text{state}$ 后 $D - i$ 维相同的所有点对于 $\text{state}$ 点高维前缀和的贡献。由定义可知 $\text{sum}[0][\text{state}] = f[\text{state}]$,以及 $\text{sum}[\text{state}] = \text{sum}[D][\text{state}]$。  
      其递推关系为 $\text{sum}[i][\text{state}] = \text{sum}[i - 1][\text{state}] + \text{sum}[i][\text{state}']$,其中 $\text{state}'$ 为第 $i$ 维恰好比 $\text{state}$ 少 $1$ 的点。该方法的复杂度为 $O(D \times |U|)$,其中 $|U|$ 为高维空间 $U$ 的大小。  
      一种实现的伪代码如下：
      $$
      \begin{array}{ll}
      \textbf{for } state \\\\
      \qquad sum[state] \gets f[state] \\\\
      \textbf{for } i \gets 0 \textbf{ to } D \\\\
      \qquad \textbf{for } state' \textbf{ in } \textit{lexicographical order} \\\\
      \qquad \qquad sum[state] \gets sum[state] + sum[state']
      \end{array}$$
   - 树上前缀和  
    设 $\textit{sum}_i$ 表示结点 $i$ 到根节点的权值总和。
    然后：  
      - 若是点权,$x,y$ 路径上的和为 $\textit{sum}_x + \textit{sum}_y - \textit{sum}_\textit{lca} - \textit{sum}_{\textit{fa}_\textit{lca}}$。  
      - 若是边权,$x,y$ 路径上的和为 $\textit{sum}_x + \textit{sum}_y - 2\cdot\textit{sum}_{lca}$。

### 差分
  - 概念：与前缀和相对的操作  
  - 库函数  
    C++ 标准库中实现了差分函数 std::adjacent_difference,定义于头文件 \<numeric> 中。
  - 用法  
    它可以维护多次对序列的一个区间加上一个数,并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。
  - 树上差分
    - 概念  
      树上差分可以理解为对树上的某一段路径进行差分操作,这里的路径可以类比一维数组的区间进行理解。例如在对树上的一些路径进行频繁操作,并且询问某条边或者某个点在经过操作后的值的时候,就可以运用树上差分思想了。  
      树上差分通常会结合 树基础 和 最近公共祖先 来进行考察。树上差分又分为 **点差分** 与 **边差分**,在实现上会稍有不同。
    - 点差分  
      举例：对树上的一些路径 $\delta(s_1,t_1), \delta(s_2,t_2), \delta(s_3,t_3)\dots$ 进行访问,问一条路径 $\delta(s,t)$ 上的点被访问的次数。  
      对于一次 $\delta(s,t)$ 的访问,需要找到 $s$ 与 $t$ 的公共祖先,然后对这条路径上的点进行访问(点的权值加一),若采用DFS对每个点进行访问,由于有太多的路径需要访问,时间上承受不了。这里进行差分操作：
      $$
      \begin{aligned}
      &d_s\leftarrow d_s+1\\\\
      &d_{lca}\leftarrow d_{\textit{lca}}-1\\\\
      &d_t\leftarrow d_t+1\\\\
      &d_{f(\textit{lca})}\leftarrow d_{f(\textit{lca})}-1\\\\
      \end{aligned}$$
      其中 $f(x)$ 表示 $x$ 的父亲节点,$d_i$ 为点权 $a_i$ 的差分数组。可以发现实际上点差分的操作和上文一维数组的差分操作是类似的。
    - 边差分  
      若是对路径中的边进行访问,就需要采用边差分策略了,使用以下公式：
      $$ 
      \begin{aligned}
      &d_s\leftarrow d_s+1\\\\
      &d_t\leftarrow d_t+1\\\\
      &d_{\textit{lca}}\leftarrow d_{\textit{lca}}-2\\\\
      \end{aligned}
      $$
      由于在边上直接进行差分比较困难,所以将本来应当累加到红色边上的值向下移动到附近的点里,那么操作起来也就方便了。对于公式,有了点差分的理解基础后也不难推导,同样是对两段区间进行差分。

# 四、二分&三分
### 二分法
  - 库函数  
    C++ 标准库中实现了查找首个不小于给定值的元素的函数 std::lower_bound 和查找首个大于给定值的元素的函数 std::upper_bound,二者均定义于头文件 \<algorithm> 中。
    二者均采用二分实现,所以调用前必须保证元素有序。
  - 条件  
    1.答案在一个固定区间内;  
    2.可能查找一个符合条件的值不是很容易,但是要求能比较容易地判断某个值是否是符合条件的;  
    3.可行解对于区间满足一定的单调性。换言之,如果 $x$ 是符合条件的,那么有 $x + 1$ 或者 $x - 1$ 也符合条件。(这样下来就满足了上面提到的单调性)  
    注意,这里的有序是广义的有序,如果一个数组中的左侧或者右侧都满足某一种条件,而另一侧都不满足这种条件,也可以看作是一种有序(如果把满足条件看做 1,不满足看做 0,至少对于这个条件的这一维度是有序的)。换言之,**二分搜索法可以用来查找满足某种条件的最大(最小)的值。**
  - 二分答案  
    解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性,则满足使用二分法的条件。把这里的枚举换成二分,就变成了「二分答案」。 

### 三分法
  - 作用  
    如果需要求出单峰函数的极值点，通常使用二分法衍生出的三分法求单峰函数的极值点。  
    （**注意**:只要函数是单峰函数，三分法既可以求出其最大值，也可以求出其最小值。）  
    三分法与二分法的基本思想类似，但每次操作需在当前区间 $[l,r]$（下图中除去虚线范围内的部分）内任取两点 $lmid,rmid(lmid < rmid)$（下图中的两蓝点）。如下图，如果 $f(lmid)<f(rmid)$，则在 $[rmid,r]$（下图中的红色部分）中函数必然单调递增，最小值所在点（下图中的绿点）必然不在这一区间内，可舍去这一区间。反之亦然。（**注意**:在计算 $lmid$ 和 $rmid$ 时，需要防止数据溢出的现象出现。)  
    三分法每次操作会舍去两侧区间中的其中一个。为减少三分法的操作次数，应使两侧区间尽可能大。因此，每一次操作时的 $lmid$ 和 $rmid$ 分别取 $mid-\varepsilon$ 和 $mid+\varepsilon$ 是一个不错的选择。

# 五、倍增&ST表
### 倍增
  - 概念  
    倍增算法，顾名思义，就是不断地翻倍。  
    虽然是一种基础算法，但它能够使得线性的处理转化为对数级的处理，大大地优化时间复杂度，在很多算法中都有应用。
  - 操作过程  
    1.对 $[1,n]$ 范围内数字预处理，记录 $2^k$ 次操作后的结果
    2.当进行询问时遍历询问数字的二进制位，对每一位结果进行合并
  - 范例（[【朝夕的ACM笔记】算法基础-倍增](https://zhuanlan.zhihu.com/p/122413160)引例二）
    - 题面  
      有一个环状的操场，操场被分割为 $[1,n]$ 个小块，每个小块上写着一个数字。  有一只小白兔站在操场的起点，它每次可以跳 $n$ 个小块，然后拿走等同于它所站小块上数字数量的胡萝卜，问它跳 $m$ 次，总共可以拿到几个胡萝卜？
      如果能够算出来的话，小白兔就能把所有的胡萝卜都带回家吃啦！
      注： $1 \leq k \leq n \leq 10^6,1\leq m \leq 10^{18}$ 。
    - 思路  
      记录挑 $1,2,4,8,16\dots 2^{\lfloor \log_2m\rfloor}$ 次分别能够拿到的胡萝卜数，就能得到跳 $[1,m]$ 区间内任何一个数字能拿到的胡萝卜数。
    - 实现  
      我们设 $to[x][i]$ 代表从起点 $x$ 跳 $2^i$ 步后达到的小块编号，$carrot[x][i]$ 表示从起点 $x$ 跳 $2^i$ 步后能拿到的胡萝卜总数。  
      则有式子：  
      $to[x][i] = to[to[x][x-1]][i-1]$。即挑 $2^i$ 步相当于先跳 $2^{i-1}$ 步再跳 $2^{i-1}$ 步。  
      $carrot[x][i] = carrot[x][i-1] + carrot[to[x][x-1]][i-1]$
  - 总结  
    可以说，倍增算法的核心式子就是 $to[x][i] = to[to[x][x-1]][i-1]$   
    即：对于 $2^i$ 的处理，我们总可以通过 $2^{i-1}+2^{i-1}$ 来得到，而非 $(2^i-1)+1$ 得到。
### ST表
  - 概念  
    ST 表基于倍增思想，可以做到 $\Theta(n\log n)$ 预处理，$\Theta(1)$ 回答每个询问。但是**不支持修改操作**。  
    基于倍增思想，我们考虑如何求出区间最大值。可以发现，如果按照一般的倍增流程，每次跳 $2^i$ 步的话，询问时的复杂度仍旧是 $\Theta(\log n)$，并没有比线段树更优，反而预处理一步还比线段树慢。  
    我们发现 $\max(x,x)=x$，也就是说，区间最大值是一个具有「可重复贡献」性质的问题。即使用来求解的预处理区间有重叠部分，只要这些区间的并是所求的区间，最终计算出的答案就是正确的。  
    如果手动模拟一下，可以发现我们能使用至多两个预处理过的区间来覆盖询问区间，也就是说询问时的时间复杂度可以被降至 $\Theta(1)$，在处理有大量询问的题目时十分有效。
  - 使用条件  
    原问题必须是**可重复贡献问题**（是指对于运算 $\operatorname{opt}$，满足 $x\operatorname{opt} x=x$，则对应的区间询问就是一个可重复贡献问题。例如，最大值有 $\max(x,x)=x$，$gcd$ 有 $\operatorname{gcd}(x,x)=x$，所以区间最大（最小）值（RMQ）和区间GCD就是一个可重复贡献问题。像区间和就不具有这个性质，如果求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次，这是我们所不愿意看到的。另外，$\operatorname{opt}$ 还必须满足结合律才能使用 ST 表求解。）
  - 思路  
    Step 1:预处理  
      1.令 $f(i,j)$ 表示区间 $[i,i+2^j-1]$ 的答案。  
      2.根据定义式，第二维就相当于倍增的时候「跳了 $2^j-1$ 步」，依据倍增的思路，写出状态转移方程：$f(i,j)=\operatorname{opt}(f(i,j-1),f(i+2^{j-1},j-1))$。
      3.根据题面确定初始条件（如RMQ问题中有$ f(i,0)=a_i$）  
    Step 2:查询  
      对于每个询问 $[l,r]$，我们把它分成两部分：$[l,l+2^s-1]$ 与 $[r-2^s+1,r]$，其中 $s=\left\lfloor\log_2(r-l+1)\right\rfloor$。两部分的结果的$\operatorname{opt}$结果就是回答。
      注：由于原问题是「可重复贡献问题」，重叠并不会对原问题产生影响。又因为这两个区间完全覆盖了 $[l,r]$，可以保证答案的正确性。
  - 常见应用  
    RMQ问题、「区间按位和」问题、「区间按位或」问题、「区间 GCD」问题  
    如果分析一下，「可重复贡献问题」一般都带有某种类似 RMQ 的成分。例如「区间按位与」就是每一位取最小值，而「区间 GCD」则是每一个质因数的指数取最小值。

# 六、构造法

