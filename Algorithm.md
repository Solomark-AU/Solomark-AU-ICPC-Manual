# 一、排序
### 提示：一般情况下直接使用sort函数即可
### 冒泡排序
  - 算法思想  
    使用一个指针从左向右扫描,若当前位置比前一位置小/大则交换,否则不作操作  
    第 $n$ 轮确定第 $n$ 小的数字  
    值得注意的是,如果一轮当中没有交换操作则可认定排序完成  

### 快速排序
  - 算法思想  
    在序列中选择一个数字作为基准(称基准数)  
    将序列中小于该基准数的数字移动至基准数左侧,大于的放在右侧  
    对左右两个子序列递归进行上述操作  
    对返回的数列进行合并并返回上一级  
    
### 归并排序
  - 算法思想  
    将序列从中间平分直至每一个子序列长度均为 $1$  
    随后重复进行合并操作,取两个子序列中最小的数放入合并结果数组中并删去  
    重复上一步操作直到完成合并  
    返回上一级
  - 经典应用：求逆序对数量  

  ### 基数排序
  - 算法思想
    一种非比较型的排序算法最早用于解决卡片排序的问题  
    基数排序将待排序的元素拆分为 $k$ 个关键字  
    逐一对各个关键字排序后完成对所有元素的排序
  - $k-$关键字的比较
    下面用 $a_i$ 表示元素 $a$ 的第 $i$ 关键字  
    假如元素有 $k$ 个关键字,对于两个元素 $a$ 和 $b$,默认的比较方法是：  
    比较两个元素的第 $1$ 关键字 $a_1$ 和 $b_1$,如果 $a_1 < b_1$ 则 $a < b$,如果 $a_1 > b_1$ 则 $a > b$,如果 $a_1 = b_1$ 则进行下一步;
    比较两个元素的第 $2$ 关键字 $a_2$ 和 $b_2$,如果 $a_2 < b_2$ 则 $a < b$,如果 $a_2 > b_2$ 则 $a > b$,如果 $a_2 = b_2$ 则进行下一步;
    ……
    比较两个元素的第 $k$ 关键字 $a_k$ 和 $b_k$,如果 $a_k < b_k$ 则 $a < b$,如果 $a_k > b_k$ 则 $a > b$,如果 $a_k = b_k$ 则 $a = b$。
  - 稳定性
    如果对内层关键字的排序是稳定的,则基数排序是稳定的。
  - 时间复杂度
    通常而言,基数排序比基于比较的排序算法(比如快速排序)要快。但由于需要额外的内存空间,因此当内存空间稀缺时,原地置换算法(比如快速排序)或许是个更好的选择。
    一般来说,如果每个关键字的值域都不大,就可以使用 计数排序 作为内层排序,此时的复杂度为 $O(kn+\sum\limits_{i=1}^k w_i)$,其中 $w_i$ 为第 $i$ 关键字的值域大小。如果关键字值域很大,就可以直接使用基于比较的 $O(nk\log n)$ 排序而无需使用基数排序了。

  - 空间复杂度
    空间复杂度总为 $O(k+n)$

  ### 总结
  | 排序算法 | 最优时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 |            额外内存             | 稳定性 |           备注            |
  | :------: | :------------: | :------------: | :------------: | :-----------------------------: | :----: | :-----------------------: |
  | 插入排序 |     $O(n)$     |    $O(n^2)$    |    $O(n^2)$    |             $O(1)$              |   是   |  复杂度与逆序对个数相关   |
  | 选择排序 |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |             $O(1)$              |   否   |    额外空间可使其稳定     |
  | 冒泡排序 |    $O(n^2)$    |    $O(n^2)$    |    $O(n^2)$    |             $O(1)$              |   是   |          代码短           |
  |  堆排序  | $O(n\log_2n)$  | $O(n\log_2n)$  | $O(n\log_2n)$  |             $O(1)$              |   否   |                           |
  | 快速排序 | $O(n\log_2n)$  | $O(n\log_2n)$  |    $O(n^2)$    | 平均$O(n\log_2n)$,最坏$O(n^2)$ |   否   | 常使用$O(n\log_2n)$栈空间 |
  | 归并排序 | $O(n\log_2n)$  | $O(n\log_2n)$  | $O(n\log_2n)$  |             $O(n)$              |   是   |                           |

# 二、贪心
- 概念  
  贪心算法(英语：greedy algorithm),是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪,每一步行动总是按某种指标选取最优的操作。而且他目光短浅,总是只看眼前,并不考虑以后可能造成的影响。
- 基本思路  
  1. 建立数学模型  
  2. 把求解的问题分为若干个子问题
  3. 对每一个子问题求解得到局部最优解
  4. 局部最优解合并为全局最优解
  注：不同于dp,贪心不保存决策过程每一个子问题解的具体值,不能回退
- 证明方法  
  1. 反证法：如果交换方案中任意两个元素/相邻的两个元素后,答案不会变得更好,那么可以推定目前的解已经是最优解了。  
  2. 归纳法：先算得出边界情况(例如 $n = 1$)的最优解 $F_1$,然后再证明：对于每个 $n$,$F_{n+1}$ 都可以由 $F_{n}$ 推导出结果。
- 常用解法  
  1.排序解法  
    用排序法常见的情况是输入一个包含几个(一般一到两个)权值的数组,通过排序然后遍历模拟计算的方法求出最优值。  
    e.g.[「NOIP2012」 提高组 国王游戏](https://www.luogu.com.cn/problem/P1080)   
    - 题面  
      恰逢 H 国国庆,国王邀请 $n$ 位大臣来玩一个有奖游戏。首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。然后,让这 $n$ 位大臣排成一排,国王站在队伍的最前面。排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。  
      国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。注意,国王的位置始终在队伍的最前面。
    - 解题思路  
      设排序后第 $i$ 个大臣左右手上的数分别为 $a_i$, $b_i$。考虑通过邻项交换法推导贪心策略。  
      用 $s$ 表示第 $i$ 个大臣前面所有人的 $a_i$ 的乘积,那么第 $i$ 个大臣得到的奖赏就是$\dfrac{s} {b_i}$,第 $i + 1$ 个大臣得到的奖赏就是$\dfrac{s \cdot a_i} {b_{i+1}}$。  
      如果我们交换第 $i$ 个大臣与第 $i + 1$ 个大臣,那么此时的第 $i$ 个大臣得到的奖赏就是$\dfrac{s} {b_{i+1}}$,第 $i + 1$ 个大臣得到的奖赏就是$\dfrac{s \cdot a_{i+1}} {b_i}$。  
      如果交换前更优当且仅当$\max \left(\dfrac{s} {b_i}, \dfrac{s \cdot a_i} {b_{i+1}}\right)  < \max \left(\dfrac{s} {b_{i+1}}, \dfrac{s \cdot a_{i+1}} {b_i}\right)$  
      提取出相同的 $s$ 并约分得到$\max \left(\dfrac{1} {b_i}, \dfrac{a_i} {b_{i+1}}\right)  < \max \left(\dfrac{1} {b_{i+1}}, \dfrac{a_{i+1}} {b_i}\right)$  
      然后分式化成整式得到$\max (b_{i+1}, a_i\cdot b_i)  < \max (b_i, a_{i+1}\cdot b_{i+1})$   

  2.后悔解法  
    无论当前的选项是否最优都接受,然后进行比较,如果选择之后不是最优了,则反悔,舍弃掉这个选项;否则,正式接受。如此往复。  
    e.g.[「USACO09OPEN」工作调度 Work Scheduling](https://www.luogu.com.cn/problem/P2949)  
    - 题面  
      约翰的工作日从 $0$ 时刻开始,有 $10^9$ 个单位时间。在任一单位时间,他都可以选择编号 $1$ 到 $N$ 的 $N(1 \leq N \leq 10^5)$ 项工作中的任意一项工作来完成。工作 $i$ 的截止时间是 $D_i(1 \leq D_i \leq 10^9)$,完成后获利是 $P_i( 1\leq P_i\leq 10^9 )$。在给定的工作利润和截止时间下,求约翰能够获得的利润最大为多少。 
    - 解题思路  
      1.先假设每一项工作都做,将各项工作按截止时间排序后入队;  
      2.在判断第 $i$ 项工作做与不做时,若其截至时间符合条件,则将其与队中报酬最小的元素比较,若第 $i$ 项工作报酬较高(后悔),则 $ans += a[i].p - q.top()$。  
      用优先队列(小根堆)来维护队首元素最小。  
      3.当 $a[i].d<=q.size()$ 时可以理解为从 $0$ 开始到 $a[i].d$ 这个时间段只能做 $a[i].d$ 个任务,而若 $q.size()>=a[i].d$ 说明完成 $q.size()$ 个任务时间大于等于 $a[i].d$ 的时间,所以当第 $i$ 个任务获利比较大的时候应该把最小的任务从优先级队列中换出。
- 经典应用：哈夫曼树与哈夫曼编码

# 三、前缀和 & 差分  
### 前缀和
   - 库函数  
    C++ 标准库中实现了前缀和函数 std::partial_sum,定义于头文件 \<numeric> 中。
   - 多维前缀和  
    1.基于容斥原理计算  
    2.dp计算(俗称高维前缀和)
      设高维空间 $U$ 共有 $D$ 维,需要对 $f[\cdot]$ 求高维前缀和 $\text{sum}[\cdot]$。令 $\text{sum}[i][\text{state}]$ 表示同 $\text{state}$ 后 $D - i$ 维相同的所有点对于 $\text{state}$ 点高维前缀和的贡献。由定义可知 $\text{sum}[0][\text{state}] = f[\text{state}]$,以及 $\text{sum}[\text{state}] = \text{sum}[D][\text{state}]$。  
      其递推关系为 $\text{sum}[i][\text{state}] = \text{sum}[i - 1][\text{state}] + \text{sum}[i][\text{state}']$,其中 $\text{state}'$ 为第 $i$ 维恰好比 $\text{state}$ 少 $1$ 的点。该方法的复杂度为 $O(D \times |U|)$,其中 $|U|$ 为高维空间 $U$ 的大小。  
      一种实现的伪代码如下：
      $$
      \begin{array}{ll}
      \textbf{for } state \\
      \qquad sum[state] \gets f[state] \\
      \textbf{for } i \gets 0 \textbf{ to } D \\
      \qquad \textbf{for } state' \textbf{ in } \text{lexicographical order} \\
      \qquad \qquad sum[state] \gets sum[state] + sum[state']
      \end{array}$$
   - 树上前缀和  
    设 $\textit{sum}_i$ 表示结点 $i$ 到根节点的权值总和。
    然后：  
      - 若是点权,$x,y$ 路径上的和为 $\textit{sum}_x + \textit{sum}_y - \textit{sum}_\textit{lca} - \textit{sum}_{\textit{fa}_\textit{lca}}$。  
      - 若是边权,$x,y$ 路径上的和为 $\textit{sum}_x + \textit{sum}_y - 2\cdot\textit{sum}_{lca}$。

### 差分  
    - 概念：与前缀和相对的操作  
    - 库函数  
      C++ 标准库中实现了差分函数 std::adjacent_difference,定义于头文件 \<numeric> 中。
    - 用法  
      它可以维护多次对序列的一个区间加上一个数,并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。
    - 树上差分
      - 概念  
        树上差分可以理解为对树上的某一段路径进行差分操作,这里的路径可以类比一维数组的区间进行理解。例如在对树上的一些路径进行频繁操作,并且询问某条边或者某个点在经过操作后的值的时候,就可以运用树上差分思想了。  
        树上差分通常会结合 树基础 和 最近公共祖先 来进行考察。树上差分又分为 **点差分** 与 **边差分**,在实现上会稍有不同。
      - 点差分  
        举例：对树上的一些路径 $\delta(s_1,t_1), \delta(s_2,t_2), \delta(s_3,t_3)\dots$ 进行访问,问一条路径 $\delta(s,t)$ 上的点被访问的次数。  
        对于一次 $\delta(s,t)$ 的访问,需要找到 $s$ 与 $t$ 的公共祖先,然后对这条路径上的点进行访问(点的权值加一),若采用DFS对每个点进行访问,由于有太多的路径需要访问,时间上承受不了。这里进行差分操作：
        $$
        \begin{aligned}
        &d_s\leftarrow d_s+1\\
        &d_{lca}\leftarrow d_{\textit{lca}}-1\\
        &d_t\leftarrow d_t+1\\
        &d_{f(\textit{lca})}\leftarrow d_{f(\textit{lca})}-1\\
        \end{aligned}$$
        其中 $f(x)$ 表示 $x$ 的父亲节点,$d_i$ 为点权 $a_i$ 的差分数组。可以发现实际上点差分的操作和上文一维数组的差分操作是类似的。
      - 边差分  
        若是对路径中的边进行访问,就需要采用边差分策略了,使用以下公式：
        $$ 
        \begin{aligned}
        &d_s\leftarrow d_s+1\\
        &d_t\leftarrow d_t+1\\
        &d_{\textit{lca}}\leftarrow d_{\textit{lca}}-2\\
        \end{aligned}
        $$
        由于在边上直接进行差分比较困难,所以将本来应当累加到红色边上的值向下移动到附近的点里,那么操作起来也就方便了。对于公式,有了点差分的理解基础后也不难推导,同样是对两段区间进行差分。

# 四、二分&三分
### 二分法
  - 库函数  
    C++ 标准库中实现了查找首个不小于给定值的元素的函数 std::lower_bound 和查找首个大于给定值的元素的函数 std::upper_bound,二者均定义于头文件 \<algorithm> 中。
    二者均采用二分实现,所以调用前必须保证元素有序。
  - 条件  
    1.答案在一个固定区间内;
    2.可能查找一个符合条件的值不是很容易,但是要求能比较容易地判断某个值是否是符合条件的;
    3.可行解对于区间满足一定的单调性。换言之,如果 $x$ 是符合条件的,那么有 $x + 1$ 或者 $x - 1$ 也符合条件。(这样下来就满足了上面提到的单调性)
    注意,这里的有序是广义的有序,如果一个数组中的左侧或者右侧都满足某一种条件,而另一侧都不满足这种条件,也可以看作是一种有序(如果把满足条件看做 1,不满足看做 0,至少对于这个条件的这一维度是有序的)。换言之,**二分搜索法可以用来查找满足某种条件的最大(最小)的值。**
  - 二分答案  
    解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性,则满足使用二分法的条件。把这里的枚举换成二分,就变成了「二分答案」。 

### 三分法
  - 作用
    如果需要求出单峰函数的极值点，通常使用二分法衍生出的三分法求单峰函数的极值点。  
    （**注意**:只要函数是单峰函数，三分法既可以求出其最大值，也可以求出其最小值。）  
    三分法与二分法的基本思想类似，但每次操作需在当前区间 $[l,r]$（下图中除去虚线范围内的部分）内任取两点 $lmid,rmid(lmid < rmid)$（下图中的两蓝点）。如下图，如果 $f(lmid)<f(rmid)$，则在 $[rmid,r]$（下图中的红色部分）中函数必然单调递增，最小值所在点（下图中的绿点）必然不在这一区间内，可舍去这一区间。反之亦然。（**注意**:在计算 $lmid$ 和 $rmid$ 时，需要防止数据溢出的现象出现。)  
    三分法每次操作会舍去两侧区间中的其中一个。为减少三分法的操作次数，应使两侧区间尽可能大。因此，每一次操作时的 $lmid$ 和 $rmid$ 分别取 $mid-\varepsilon$ 和 $mid+\varepsilon$ 是一个不错的选择。
# 五、倍增


# 六、构造法

