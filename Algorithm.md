# 一、排序
  ### 0. 提示：一般情况下直接使用sort函数即可
  ### 1. 冒泡排序
  - 算法思想  
    使用一个指针从左向右扫描，若当前位置比前一位置小/大则交换，否则不作操作  
    第 $n$ 轮确定第 $n$ 小的数字  
    值得注意的是，如果一轮当中没有交换操作则可认定排序完成  

  ### 2. 快速排序
  - 算法思想  
    在序列中选择一个数字作为基准(称基准数)  
    将序列中小于该基准数的数字移动至基准数左侧，大于的放在右侧  
    对左右两个子序列递归进行上述操作  
    对返回的数列进行合并并返回上一级  
    
  ### 3. 归并排序
  - 算法思想  
    将序列从中间平分直至每一个子序列长度均为 $1$  
    随后重复进行合并操作，取两个子序列中最小的数放入合并结果数组中并删去  
    重复上一步操作直到完成合并  
    返回上一级
  - 经典应用：求逆序对数量  

  ### 4. 基数排序
  - 算法思想
    一种非比较型的排序算法最早用于解决卡片排序的问题  
    基数排序将待排序的元素拆分为 $k$ 个关键字  
    逐一对各个关键字排序后完成对所有元素的排序
  - $k-$关键字的比较
    下面用 $a_i$ 表示元素 $a$ 的第 $i$ 关键字  
    假如元素有 $k$ 个关键字，对于两个元素 $a$ 和 $b$，默认的比较方法是：  
    比较两个元素的第 $1$ 关键字 $a_1$ 和 $b_1$，如果 $a_1 < b_1$ 则 $a < b$，如果 $a_1 > b_1$ 则 $a > b$，如果 $a_1 = b_1$ 则进行下一步；
    比较两个元素的第 $2$ 关键字 $a_2$ 和 $b_2$，如果 $a_2 < b_2$ 则 $a < b$，如果 $a_2 > b_2$ 则 $a > b$，如果 $a_2 = b_2$ 则进行下一步；
    ……
    比较两个元素的第 $k$ 关键字 $a_k$ 和 $b_k$，如果 $a_k < b_k$ 则 $a < b$，如果 $a_k > b_k$ 则 $a > b$，如果 $a_k = b_k$ 则 $a = b$。
  - 稳定性
    如果对内层关键字的排序是稳定的，则基数排序是稳定的。
  - 时间复杂度
    通常而言，基数排序比基于比较的排序算法（比如快速排序）要快。但由于需要额外的内存空间，因此当内存空间稀缺时，原地置换算法（比如快速排序）或许是个更好的选择。
    一般来说，如果每个关键字的值域都不大，就可以使用 计数排序 作为内层排序，此时的复杂度为 $\Omicron(kn+\sum\limits_{i=1}^k w_i)$，其中 $w_i$ 为第 $i$ 关键字的值域大小。如果关键字值域很大，就可以直接使用基于比较的 $\Omicron(nk\log n)$ 排序而无需使用基数排序了。

  - 空间复杂度
    空间复杂度总为 $\Omicron(k+n)$

  ### 总结
  | 排序算法 |    最优时间复杂度    |    平均时间复杂度    |    最坏时间复杂度    |                   额外内存                    | 稳定性 |               备注               |
  | :------: | :------------------: | :------------------: | :------------------: | :-------------------------------------------: | :----: | :------------------------------: |
  | 插入排序 |    $\Omicron(n)$     |   $\Omicron(n^2)$    |   $\Omicron(n^2)$    |                 $\Omicron(1)$                 |   是   |      复杂度与逆序对个数相关      |
  | 选择排序 |   $\Omicron(n^2)$    |   $\Omicron(n^2)$    |   $\Omicron(n^2)$    |                 $\Omicron(1)$                 |   否   |        额外空间可使其稳定        |
  | 冒泡排序 |   $\Omicron(n^2)$    |   $\Omicron(n^2)$    |   $\Omicron(n^2)$    |                 $\Omicron(1)$                 |   是   |              代码短              |
  |  堆排序  | $\Omicron(n\log_2n)$ | $\Omicron(n\log_2n)$ | $\Omicron(n\log_2n)$ |                 $\Omicron(1)$                 |   否   |                                  |
  | 快速排序 | $\Omicron(n\log_2n)$ | $\Omicron(n\log_2n)$ |   $\Omicron(n^2)$    | 平均$\Omicron(n\log_2n)$，最坏$\Omicron(n^2)$ |   否   | 常使用$\Omicron(n\log_2n)$栈空间 |
  | 归并排序 | $\Omicron(n\log_2n)$ | $\Omicron(n\log_2n)$ | $\Omicron(n\log_2n)$ |                 $\Omicron(n)$                 |   是   |                                  |

# 二、贪心
- 概念  
  贪心算法（英语：greedy algorithm），是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。
- 基本思路  
  1. 建立数学模型  
  2. 把求解的问题分为若干个子问题
  3. 对每一个子问题求解得到局部最优解
  4. 局部最优解合并为全局最优解
  注：不同于dp,贪心不保存决策过程每一个子问题解的具体值，不能回退
- 证明方法  
  1. 反证法：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。  
  2. 归纳法：先算得出边界情况（例如 $n = 1$）的最优解 $F_1$，然后再证明：对于每个 $n$，$F_{n+1}$ 都可以由 $F_{n}$ 推导出结果。
- 常用解法  
  1. 排序解法  
    用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。  
    e.g.[「NOIP2012」 提高组 国王游戏](https://www.luogu.com.cn/problem/P1080)   
    - 题面  
      恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。  
      国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。
    - 解题思路  
      设排序后第 $i$ 个大臣左右手上的数分别为 $a_i$, $b_i$。考虑通过邻项交换法推导贪心策略。  
      用 $s$ 表示第 $i$ 个大臣前面所有人的 $a_i$ 的乘积，那么第 $i$ 个大臣得到的奖赏就是$\dfrac{s} {b_i}$，第 $i + 1$ 个大臣得到的奖赏就是$\dfrac{s \cdot a_i} {b_{i+1}}$。  
      如果我们交换第 $i$ 个大臣与第 $i + 1$ 个大臣，那么此时的第 $i$ 个大臣得到的奖赏就是$\dfrac{s} {b_{i+1}}$，第 $i + 1$ 个大臣得到的奖赏就是$\dfrac{s \cdot a_{i+1}} {b_i}$。  
      如果交换前更优当且仅当$\max \left(\dfrac{s} {b_i}, \dfrac{s \cdot a_i} {b_{i+1}}\right)  < \max \left(\dfrac{s} {b_{i+1}}, \dfrac{s \cdot a_{i+1}} {b_i}\right)$  
      提取出相同的 $s$ 并约分得到$\max \left(\dfrac{1} {b_i}, \dfrac{a_i} {b_{i+1}}\right)  < \max \left(\dfrac{1} {b_{i+1}}, \dfrac{a_{i+1}} {b_i}\right)$  
      然后分式化成整式得到$\max (b_{i+1}, a_i\cdot b_i)  < \max (b_i, a_{i+1}\cdot b_{i+1})$   

  2. 后悔解法  
    无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。  
    e.g.[「USACO09OPEN」工作调度 Work Scheduling](https://www.luogu.com.cn/problem/P2949)  
    - 题面  
      约翰的工作日从 $0$ 时刻开始，有 $10^9$ 个单位时间。在任一单位时间，他都可以选择编号 $1$ 到 $N$ 的 $N(1 \leq N \leq 10^5)$ 项工作中的任意一项工作来完成。工作 $i$ 的截止时间是 $D_i(1 \leq D_i \leq 10^9)$，完成后获利是 $P_i( 1\leq P_i\leq 10^9 )$。在给定的工作利润和截止时间下，求约翰能够获得的利润最大为多少。 
    - 解题思路  
      1.先假设每一项工作都做，将各项工作按截止时间排序后入队；  
      2.在判断第 $i$ 项工作做与不做时，若其截至时间符合条件，则将其与队中报酬最小的元素比较，若第 $i$ 项工作报酬较高（后悔），则 $ans += a[i].p - q.top()$。  
      用优先队列（小根堆）来维护队首元素最小。  
      3.当 $a[i].d<=q.size()$ 可以理解为从 $0$ 开始到 $a[i].d$ 这个时间段只能做 $a[i].d$ 个任务，而若 $q.size()>=a[i].d$ 说明完成 $q.size()$ 个任务时间大于等于 $a[i].d$ 的时间，所以当第 $i$ 个任务获利比较大的时候应该把最小的任务从优先级队列中换出。
- 经典应用：哈夫曼树与哈夫曼编码  
  - 定义  
    - 树的带权路径长度(WPL) 
      设二叉树具有 $n$ 个带权叶结点，从根结点到各叶结点的路径长度与相应叶节点权值的乘积之和称为 树的带权路径长度（Weighted Path Length of Tree，WPL）。
      设 $w_i$ 为二叉树第 $i$ 个叶结点的权值，$l_i$ 为从根结点到第 $i$ 个叶结点的路径长度，则 WPL 计算公式为：$WPL=\sum_{i=1}^nw_il_i$
    - 哈夫曼树  
      对于给定一组具有确定权值的叶结点，可以构造出不同的二叉树，其中，**WPL 最小的二叉树** 称为 **哈夫曼树（Huffman Tree）**。  
      对于哈夫曼树来说，其叶结点权值越小，离根越远，叶结点权值越大，离根越近，此外其仅有叶结点的度为 $0$，其他结点度均为 $2$。
    - 哈夫曼编码  
      在进行二进制编码时，假设所有的代码都等长，那么表示 n 个不同的字符需要 $\left \lceil \log_2 n \right \rceil$ 位，称为等长编码。  
      如果每个字符的使用频率相等，那么等长编码无疑是空间效率最高的编码方法，而如果字符出现的频率不同，则可以让频率高的字符采用尽可能短的编码，频率低的字符采用尽可能长的编码，来构造出一种不等长编码，从而获得更好的空间效率。  
      在设计不等长编码时，要考虑解码的**唯一性**，如果一组编码中任一编码都不是<u>其他任何一个编码的前缀</u>，那么称这组编码为 **前缀编码**，其保证了编码被解码时的唯一性。  
      哈夫曼树可用于构造 **最短的前缀编码**，即 **哈夫曼编码**（Huffman Code）
  - 哈夫曼树的构造流程  
    1.初始化：由给定的 $n$ 个权值构造 $n$ 棵只有一个根节点的二叉树，得到一个二叉树集合 $\mathbb{F}$。
    2.选取与合并：从二叉树集合 $\mathbb{F}$ 中选取根节点权值 **最小的两棵** 二叉树分别作为左右子树构造一棵新的二叉树，这棵新二叉树的根节点的权值为其左、右子树根结点的权值和。
    3.删除与加入：从 $\mathbb{F}$ 中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到 $\mathbb{F}$ 中。
    4.重复 2、3 步，当集合中只剩下一棵二叉树时，这棵二叉树就是哈夫曼树。
  - 哈夫曼编码的构造流程  
    1.设需要编码的字符集为：$d_1,d_2,\dots,d_n$，他们在字符串中出现的频率为：$w_1,w_2,\dots,w_n$。
    2.以 $d_1,d_2,\dots,d_n$ 作为叶结点，$w_1,w_2,\dots,w_n$ 作为叶结点的权值，构造一棵哈夫曼树。
    3.规定哈夫曼编码树的左分支代表 $0$，右分支代表 $1$，则从根结点到每个叶结点所经过的路径组成的 $0、1$ 序列即为该叶结点对应字符的编码。
# 三、分治